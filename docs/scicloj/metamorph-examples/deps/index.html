<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.0/sandstone/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/solarized-light.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-grid.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-theme-balham.min.css" rel="stylesheet" type="text/css">
        <link href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    </head>
    <body>
        <p id="loading">Loading ...</p>
        <div id="app"></div>
    </body>
    <script src="https://cdn.statically.io/gh/scicloj/gorilla-notes@master/dist/0.5.5/main.js"></script>
    <script>
     shadow.loader.load("main");
     gorilla_notes.main.main_BANG_(false, "{:options {:reverse-notes? false, :header? false, :notes-in-cards? false, :initially-collapse? false, :auto-scroll? false, :port 1903, :custom-header [:div {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} \"(notespace)\" [:p \"Tue Mar 02 17:36:58 CET 2021\"] nil [:hr]], :custom-footer [:div [:hr] [:hr]]}, :ids [\"216\" \"128\" \"100\" \"169\" \"102\" \"217\" \"131\" \"105\" \"132\" \"218\" \"170\" \"252\" \"219\" \"220\" \"174\" \"221\" \"222\" \"223\" \"253\" \"254\" \"255\" \"227\" \"256\" \"228\" \"229\" \"257\" \"258\" \"259\" \"243\" \"260\" \"261\" \"262\" \"247\" \"263\" \"249\" \"264\" \"251\"], :id->content {\"219\" [:div nil nil [:p/markdown \"fast\"]], \"258\" [:div nil nil [:p/markdown \"A concrete pipeline could look like below. In here, the fitted model is the mean of the data.\\nIt can be any function applied on the data. This will often be the training of a machine learning model.\\nAnd the `transform` divides the new data by this mean to simulate the applying of\\n the trained model to new data (= simulates prediction)\\n\"]], \"253\" [:div nil nil [:p/markdown \"Often only one step (often the last) in a longer pipeline shows this different behavior in `fit` and `transform`. All other steps, do the same in each mode.\\nThese other steps are sometimes called `pre-processing`, while the last step is called `model` \\nIn machine learning  these  2 modes are called as well train/predict.\"]], \"227\" [:div [:p/code {:code \"(def my-ml-pipeline-fn\\n  (morph/pipeline\\n   ;;  pre-processing-step 1\\n   ;;  pre-processing-step 2\\n   ;;  pre-processing-step 3\\n   ;;  model step (this function behaves differently on :mode  = :fit  and :mode = :transform )\\n   ;;    In ':fit' it fits a model from the data, in 'transform' it uses the fitted model to transform new data\\n   )\\n  )\", :bg-class \"bg-light\"}] nil nil], \"263\" [:div [:p/code {:code \"(def fitted-pipeline\\n  (my-ml-pipeline-fn {:metamorph/data train-data\\n                      :metamorph/mode :fit}))\", :bg-class \"bg-light\"}] nil nil], \"105\" [:div [:p/code {:code \"(pipe-fn {:metamorph/data \\\"hello world\\\"})\", :bg-class \"bg-light\"}] nil [:p/code {:code \"{:metamorph/data \\\"hello\\\",\\n :str-length-1 11,\\n :str-length-2 5,\\n :sum-str-length 16}\\n\"}]], \"251\" [:div [:p/code {:code \"predicted-pipeline\", :bg-class \"bg-light\"}] nil [:p/code {:code \"{:metamorph/data (5/3 2 7/3), 1 3}\\n\"}]], \"169\" [:div nil nil [:p/markdown \"For this case, arbitrary objects can be stored in the context map.\"]], \"221\" [:div nil nil [:p/markdown \"In statistical learning, or machine learning, a special kind of data transformations appears.\"]], \"259\" [:div [:p/code {:code \"(def my-ml-pipeline-fn\\n  (morph/pipeline\\n\\n   (fn [ctx]\\n     (let [data (:metamorph/data ctx)]\\n       (assoc ctx\\n              :metamorph/data (map inc data)\\n              )))\\n\\n\\n   (fn [{:metamorph/keys [id data mode] :as ctx}]\\n     (case mode\\n       :fit (let [fitted-model\\n                  (/\\n                   (apply + data)\\n                   (count data))]\\n              (assoc ctx id fitted-model))\\n       :transform (let [fitted-model (get ctx id)\\n                        transformed-data (map\\n                                          #(/ % fitted-model)\\n                                          data) ]\\n                    (assoc ctx :metamorph/data transformed-data))))))\", :bg-class \"bg-light\"}] nil nil], \"249\" [:div nil nil [:p/markdown \"Now the trained model is inside the fitted pipeline context.\\nAnd we can then merge the fitted ctx with new model and new data to run the pipeline in mode :transform.\\nThis will execute the :transform branch of the model functions.\\n\"]], \"228\" [:div [:p/code {:code \"(def test-data [4 5 6])\", :bg-class \"bg-light\"}] nil nil], \"247\" [:div nil nil [:p/markdown \"We run the pipeline ones in mode :fit, which will call the ':fit' branch in the model function\"]], \"128\" [:div nil nil [:p/markdown \"# Tranformation step with multiple outputs\"]], \"261\" [:div [:p/code {:code \"(def train-data [1 2 3])\", :bg-class \"bg-light\"}] nil nil], \"100\" [:div nil nil [:p/markdown \" Sometimes we want to add a transformation step with multiple outputs.\\nOr the shape of output is not compatible with the main data object\"]], \"222\" [:div nil nil [:p/markdown \"They fall under the terms of 'fitting a model to data' and 'applying a fitted model to new data'.\\nof a pipeline\"]], \"218\" [:div [:p/code {:code \"(def pipe-fn\\n  (morph/pipeline\\n   (memoize\\n    (fn [ctx]\\n      (let [s (:metamorph/data ctx)]\\n        (assoc ctx\\n               :str-length-1 (count s)\\n               :metamorph/data\\n               (subs  (:metamorph/data ctx) 0 5)))))\\n   (memoize\\n    (fn [ctx]\\n      (Thread/sleep 5000) ;; slow on first call\\n      (let [s (:metamorph/data ctx)]\\n        (assoc ctx\\n               :str-length-2 (count s)))))\\n\\n   (fn [ctx]\\n     (let [s (:metamorph/data ctx)]\\n       (assoc ctx\\n              :sum-str-length  (+ (:str-length-1 ctx)\\n                                  (:str-length-2 ctx)))))\\n\\n   ))\", :bg-class \"bg-light\"}] nil nil], \"257\" [:div [:p/code {:code \"(def predicted-pipeline\\n  (my-ml-pipeline-fn\\n   (merge fitted-pipeline               ;; the merge makes the fitted model in the fitted ctx available for the new pipeline\\n          {:metamorph/data test-data\\n           :metamorph/mode :transform})))\", :bg-class \"bg-light\"}] nil nil], \"174\" [:div nil nil [:p/markdown \"## Pipelines for machine learning\"]], \"223\" [:div nil nil [:p/markdown \"This relates to a pipeline by the observation, that machine learning requires to run a data transformation pipeline in\\n2 `modes` . Once in mode `fit` to fit a model from training data , and ones in mode `transform` to transform new data using the fitted model.\\n. So a pipeline step should behave differently, depending on the execution `mode`.\"]], \"229\" [:div [:p/code {:code \"(def fitted-pipeline\\n  (my-ml-pipeline-fn {:metamorph/data train-data\\n                      :metamorph/mode :fit}\\n                       ;; :metamorph/id is set/unset by function morph/pipeline  before/after calling each pipeline step\\n                     ))\", :bg-class \"bg-light\"}] nil nil], \"216\" [:div nil nil nil], \"217\" [:div nil nil [:p/markdown \"This pipeline is an example of\\n passing arbitrary data from one step to an other via the ctx.\\nThe pipeline takes a string, counts the length, cuts the string to 5 characters,\\ncounts length again and adds the 2 lengths together at the end.\\nThis should show, that indeed arbitrary data processing steps can be done\\nand arbitrary data can be passed from a step to any following step, as long as\\nthe steps agree on the keys to use.\"]], \"260\" [:div nil nil [:p/markdown \"This is the training and test data: \"]], \"102\" [:div [:p/code {:code \"(require '[scicloj.metamorph.core :as morph]\\n         '[clojure.string :as str])\", :bg-class \"bg-light\"}] nil nil], \"254\" [:div nil nil [:p/markdown \"The metamorph pipeline supports this by standarising a context key containing the mode, namely :metamorph/mode and two\\nvalues for it: `:fit` and `transform`.\\nIn this situation the model step wants to communicate with itself. Because it needs to pass the model trained at `:fit` to itself, via the context,\\nwhen in mode `:transform` . This is supported in `metamorph` by the `pipeline function` assigning a unique step id into the ctx (under key :metamorhp/id).\\nThis id key can be used to store the trained model while in mode `fit` and the trained model can be retrieved under the same key while in mode `transform`.\\n\"]], \"262\" [:div [:p/code {:code \"(def test-data [4 5 6])\", :bg-class \"bg-light\"}] nil nil], \"252\" [:div [:p/code {:code \"(pipe-fn {:metamorph/data \\\"my world\\\"})\", :bg-class \"bg-light\"}] nil [:p/code {:code \"{:metamorph/data \\\"my wo\\\",\\n :str-length-1 8,\\n :str-length-2 5,\\n :sum-str-length 13}\\n\"}]], \"256\" [:div [:p/code {:code \"(def train-data [1 2 3])\", :bg-class \"bg-light\"}] nil nil], \"220\" [:div [:p/code {:code \"(pipe-fn {:metamorph/data \\\"my world\\\"})\", :bg-class \"bg-light\"}] nil [:p/code {:code \"{:metamorph/data \\\"my wo\\\",\\n :str-length-1 8,\\n :str-length-2 5,\\n :sum-str-length 13}\\n\"}]], \"264\" [:div [:p/code {:code \"(def predicted-pipeline\\n  (my-ml-pipeline-fn\\n   (merge fitted-pipeline ;; the merge makes the fitted model in the fitted ctx available for the new pipeline\\n          {:metamorph/data test-data\\n           :metamorph/mode :transform})))\", :bg-class \"bg-light\"}] nil nil], \"255\" [:div nil nil [:p/markdown \"A typicall usage is this:\"]], \"170\" [:div nil nil [:p/markdown \"slow\"]], \"131\" [:div [:p/code {:code \"(def pipe-fn\\n  (morph/pipeline\\n   (fn [ctx]\\n     (let [s (:metamorph/data ctx)]\\n       (assoc ctx\\n              :str-length-1 (count s)\\n              :metamorph/data\\n              (subs  (:metamorph/data ctx) 0 5))))\\n   (fn [ctx]\\n     (let [s (:metamorph/data ctx)]\\n       (assoc ctx\\n              :str-length-2 (count s))))\\n   (fn [ctx]\\n     (let [s (:metamorph/data ctx)]\\n       (assoc ctx\\n              :sum-str-length  (+ (:str-length-1 ctx)\\n                                  (:str-length-2 ctx)))))\\n\\n   ))\", :bg-class \"bg-light\"}] nil nil], \"243\" [:div nil nil [:p/markdown \"In practice, you will use existing functions from libraries for each step, instead of writing them yourself, as we do here.\\nIt's only done to show the principles.\"]], \"132\" [:div nil nil [:p/markdown \"The resulting pipeline is still completely portable.\\nIt can be stored in a variable, and called with other data.\\nAll pipeline steps are pure functions, just relying on the input ctx,\\nso the step function can be cached easily with memoize.\"]]}}");
     document.getElementById("loading").remove();
    </script>
</html>
